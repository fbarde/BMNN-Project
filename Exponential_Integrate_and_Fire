import brian2 as b2
import matplotlib.pyplot as plt
import numpy as np
import neurodynex3.tools.input_factory as input_factory
from Passive_properties import find_E_l, find_g_l
from implementation_HH import plot_data, simulate_HH_neuron_adaptative


def sketch_f_vs_V(): # NOT USED 
    E_l= find_E_l(False)/ b2.mV
    g_l= find_g_l(False)/ b2.msiemens

    # Arbitrary values for theta and delta
    theta= -63
    delat_T= 4

    V=np.linspace(-70,-50,10)
    I_ext = 1.3917
    f_v=np.zeros(len(V))

    for i in range(len(V)):
        f_v[i] = -g_l*(V[i] - E_l) + g_l * delat_T*np.exp((V[i]-theta)/delat_T) + I_ext

    plt.plot(V, f_v)
    plt.grid()
    plt.show()


def find_theta_rh():

    plt.figure()

    #I = np.linspace(3.3917, 3.3917, 1)
    #for I_ext in I:

    current = input_factory.get_step_current(0 ,50 , b2.ms, 1.5 * b2.uA)
    state_monitor = simulate_HH_neuron_adaptative(current, 50 * b2.ms)
    plot_data(state_monitor, type='adaptative', title=None)
    plt.plot(state_monitor.vm[0] / b2.mV, state_monitor.membrane_Im[0]/b2.uamp, lw=2)
    

    #current = input_factory.get_step_current(0 ,50 , b2.ms, 1.2 * b2.uA)
    #state_monitor = simulate_HH_neuron_adaptative(current, 100 * b2.ms)

    #f_V = np.gradient(state_monitor.vm[0] / b2.mV)
    #plt.plot(state_monitor.t / b2.mV, f_V, lw=2)
    #plt.plot(state_monitor.vm[0] / b2.mV, f_V, lw=2)
    #plt.plot(state_monitor.vm[0][0] / b2.mV, f_V[0], lw=5)
    

    plt.xlabel(r"$V_m$ [mV]")
    plt.ylabel(r"$f(V_m)$ [mV]")
    plt.grid()
    #plt.legend()
    #plt.suptitle( r'Stimulation protocol: find parameter $\tau_m$.')
    plt.show()
   

if __name__ == "__main__":
    #sketch_f_vs_V()
    find_theta_rh()

